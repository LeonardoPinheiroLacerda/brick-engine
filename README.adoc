= Brick Engine Documentation
:toc: macro
:toc-title: Table of Contents
:icons: font
:source-highlighter: highlight.js

toc::[]

== Objective

The **Brick Engine** is a modular, TypeScript-based game engine designed for creating retro grid-based games (like Tetris, Snake, Breakout) that run in a browser. It leverages **P5.js** for rendering and simulates the experience of a classic handheld gaming device, complete with a dot-matrix style display, a HUD (Head-Up Display), and physical button controls.

== Key Features

* **Grid-Based Logic**: Built-in support for 2D grid management, collision detection, and row/column manipulations.
* **Retro Aesthetic**: Simulates a physical device with customizable colors and responsive layout.
* **Modular Architecture**: core functionality is split into distinct modules (Grid, Control, Renderer, State, Text, Time, Score) for clean separation of concerns.
* **Input Handling**: Unified control system supporting keyboard and on-screen button inputs.
* **Game Loop**: Separated logic ticks (game speed) from rendering frames (60fps smooth animations).
* **Debugger**: Built-in real-time state inspector. See xref:docs/reference/Debugger.adoc[Debugger Reference].

// == Engine Lifecycle

// The engine follows a strict loop to ensure logic consistency and visual smoothness.

// image::docs/images/lifecycle.svg[Engine Lifecycle]

== Installation
 
Install the package via npm:
 
[source,bash]
----
npm install brick-engine p5
npm install --save-dev @types/p5
----
 
== Getting Started

To create a game, you must extend the abstract `Game` class and implement its core abstract methods: `getPersistenceKey`, `setupGame`, `update`, `render`, `drawTitleScreen`, and `drawGameOverScreen`.

=== Example

[source,typescript]
----
import Game from './core/Game';

export default class MyGame extends Game {
    
    // 1. Setup: Called once after engine initialization
    setupGame(): void {
        // Initialize your game state here
        this.modules.state.startGame();
        this.modules.text.setTextSize(FontSize.MEDIUM);
    }

    // 2. Game Logic: Called every game tick (controlled by tickInterval)
    // Use this for movement, collision, state limits
    update(deltaTime: number): void {
        if (!this.modules.state.isPlaying()) return;
        
        // ... game logic ...
    }

    // 3. Rendering: Called every frame (60 times per second)
    // Use this for visual effects independent of game logic (particles, animations)
    render(): void {
        // ... visual effects ...
    }

    // 4. Persistence: Provide a unique key for LocalStorage prefixing
    getPersistenceKey(): string {
        return 'my-awesome-game-v1';
    }

    // 5. Title Screen: Rendered when game is ON but not STARTED
    drawTitleScreen(): void {
        this.modules.text.textOnDisplay('Press Start', { x: 0.5, y: 0.5 });
    }

    // 6. Game Over Screen: Rendered when game is over
    drawGameOverScreen(): void {
        this.modules.text.textOnDisplay('Game Over', { x: 0.5, y: 0.5 });
    }
}
----

== Structure

The engine is organized into the following core modules:
== Documentation

*   xref:docs/documentation_style_guide.adoc[Documentation Style Guide]
*   xref:docs/GAME_DEVELOPER_GUIDE.adoc[**Game Developer Guide**] (How to make games for Brick Engine)
*   xref:docs/reference/Game.adoc[Game API]
*   xref:docs/reference/GameView.adoc[GameView API]: Controls the game loop timing. It separates logic updates (Ticks) from visual rendering (Frames) to ensure consistent gameplay speed independent of frame rate.
* xref:docs/reference/GameSound.adoc[GameSound]: Manages audio playback using the **Web Audio API**. Supports multiple simultaneous sounds, volume control, and automatically syncs mute state with `GameState`.
* xref:docs/reference/GameScore.adoc[GameScore]: Tracks the current session score, calculates level/multiplier logic, and syncs the high score with `GameState` for persistence.
