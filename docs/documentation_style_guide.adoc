= Documentation Style Guide & Lessons Learned
:toc: macro
:toc-title: Table of Contents
:icons: font
:source-highlighter: highlight.js

toc::[]

This document serves as the **authoritative reference** for creating and maintaining documentation in the Brick Engine project. It consolidates lessons learned during development and defines the standards for future contributions.

== Architectural Patterns

These patterns must be reflected in both the code and the documentation.

=== 1. Centralized Persistence
*   **Principle**: `GameState` is the **single source of truth** for all persistent data (e.g., `muted`, `highScore`, `colorEnabled`).
*   **Rule**: Other modules (e.g., `GameSound`, `GameRenderer`) must **NOT** implement their own `localStorage` logic.
*   **Pattern**:
    .   **Interface**: Modules requiring state must implement `StateSyncable`.
    .   **Initialization**: `Game.ts` iterates over modules and calls `syncState(state)` on those that implement the interface.
    .   **Decoupling**: `GameState` must **NOT** have dependencies on other game modules.
    .   **Persistence Key**: The `Game` class must provide a unique key to `GameState` to prefix all `localStorage` entries.
    .   **Updates**: Modules subscribe to `GameState` changes via `state.subscribe()`.

=== 2. Event-Driven State
*   **Principle**: Reactivity over polling.
*   **Mechanism**:
    *   State properties are encapsulated with **getters/setters**.
    *   Setters automatically trigger `_notify(property, value)`.
    *   Subscribers receive the new value immediately.

=== 3. Strict Module Interfaces
*   **Principle**: Coupling through interfaces, not implementation.
*   **Guideline**: Define module shapes in `src/core/types/modules.ts` (e.g., `Sound`, `Grid`, `Time`).


=== Entry Point Responsibility

The `README.adoc` is the **main entry point** of the application and contains the "Getting Started" guide. 

**Rule**: Whenever adding new abstract methods to the `Game` class or making breaking changes to the initialization flow, you **MUST** verify and update the code snippet in `README.adoc` to ensure it remains a valid boilerplate for developers.

=== Reference Directory Structure

To maintain scannability, documentation is organized into specialized subdirectories:
- `modules/`: Core engine services (Grid, State, etc.).
- `interfaces/`: System contracts and module shapes.
- `enums/`: Fixed set of values (Color, Sound, etc.).
- `types/`: Data interfaces and composite shapes (Cell, Coordinate, etc.).
- `helpers/`: Static utility classes.

=== Style Rules
.   **Hierarchy & Granularity**:
    *   **One File Per Item**: Every public Enum, Type, Interface, and Module **MUST** have its own dedicated `.adoc` file. Do not group them.
    *   Use `===` for all methods within a module/interface file.
    *   **Separators**: Place a horizontal rule (`'''`) before every `===` header except the first one in a section.
    *   Maintain a **flat list** of methods under the `== API Reference` or `== Methods` sections.
.   **Parameters**:
    *   Use a table for arguments.
    *   **OMIT this section completely** if there are no parameters.
.   **Returns**:
    *   Describe the return value.
    *   **OMIT this section completely** if the return type is `void`.
.   **Behavior**: Use full sentences and paragraphs.
.   **Examples**: Provide realistic usage scenarios.

=== Single-Item Structure (Types, Enums, Interfaces)

For entities that define data shapes or fixed values, use the following structure:

[source,asciidoc]
----
= EntityName Reference

<Brief description of the entity's purpose and usage.>

== Attributes / Properties / Values

[cols="1,1,3"]
|===
|Name |Type |Description
|`prop1` |`Type` |Description of property 1.
|`prop2` |`Type` |Description of property 2.
|===

== General Usage

<Detailed explanation of how this entity is used within the engine's ecosystem.>
----

== Formatting Guidelines

=== AsciiDoc Features
We use **AsciiDoc** (`.adoc`) for all documentation to leverage advanced features.

*   **Headers**: Use `=` for document titles, `==` for sections.
*   **Code Blocks**: Use `[source,typescript]` for syntax highlighting.
*   **Admonitions**: Use `NOTE:`, `TIP:`, `WARNING:` for emphasis.
*   **Diagrams**: Use Mermaid via `mermaid-cli` for generation (embedded as generic images).

=== JSDoc (Source Code)
Refer to `docs/jsdoc_standard.adoc` for inline code documentation rules.
*   **Enforce**: `@param` and `@returns` for every method.
*   **Strict Typing**: No `any`.

== Lessons Learned

=== Audio Latency
*   **Issue**: `AudioContext` autoplay policy and startup latency.
*   **Solution**:
    .   Use `latencyHint: 'interactive'`.
    .   Preload all sounds into `AudioBuffer`s during `setup()`.
    .   Resume context on first user interaction if suspended.

=== Enumerations
*   **Issue**: String literals ('pressed', 'held') caused typos and refactoring pain.
*   **Solution**: Use TypeScript `enum` (e.g., `ControlEventType`) for all fixed sets of values.

=== Coordinate Systems
*   **Standard**:
    *   **Grid**: Integers `{x, y}` representing column/row index.
    *   **Display**: Normalized floats `0.0` to `1.0` (percentage of screen).
    *   Use `CoordinateHelper` methods to convert between Grid, Display, and Pixel values.

=== Decoupled State Sync
*   **Issue**: `GameState.syncModules` creates a circular dependency or high coupling by making the state module know about every other module.
*   **Solution**: Use the `StateSyncable` interface. The `Game` class (owner) handles the linking, allowing `GameState` to remain an independent "data store" module.

=== Persistence Namespacing
*   **Issue**: If multiple games built with the engine are hosted on the same domain, they share the same `localStorage`, leading to property collisions (e.g., both games trying to store `highScore`).
*   **Solution**: Require an abstract `getPersistenceKey()` method in the `Game` class and use its return value as a prefix in `GameState` (e.g., `localStorage.setItem(`${prefix}.${key}`, value)`).

=== Documentation Granularity
*   **Issue**: Grouping multiple types or enums in a single file makes the documentation harder to navigate via sidebars or search, and leads to extremely long pages.
*   **Solution**: "Explode" documentation into individual files (One File Per Item). This improves scannability and allows for precise cross-referencing.

=== Cross-Linking Context
*   **Recommendation**: When referencing an entity in a table (e.g., a return type or parameter type), always use an `xref:` link to its dedicated documentation page.
*   **Pattern**: Use relative paths (e.g., `xref:../enums/Color.adoc[Color]`) to link between subdirectories.
