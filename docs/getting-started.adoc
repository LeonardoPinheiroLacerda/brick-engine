= Getting Started Guide
:description: Detailed instructions for setting up and building games with the Brick Engine.
:toc: left
:toclevels: 3
:sectnums:
:sectlinks:
:icons: font
:source-highlighter: highlight.js

This guide provides everything you need to know to start building retro grid-based games with the **Brick Engine**.

== Installation

The fastest way to build a game is using the **Brick Engine CLI**, which scaffolds a complete project with build tools and quality checks.

=== Quick Start (CLI)

Use `npx` to create a new project without installing anything globally:

[source,bash]
----
npx brick-engine-cli init my-brick-game
----

This command will:
*   Create a project directory with a ready-to-use structure.
*   Generate `src/index.ts` with a boilerplate `Game` implementation, ready for coding.
*   Configure **Webpack** for development and production builds.
*   (Optional) Set up **ESLint** and **Prettier** for code quality.

=== Available Scripts

Once your project is created, use the following commands:

[cols="1,3", options="header"]
|===
| Command | Description

| `npm start`
| Starts the dev server with hot reload at `localhost:8080`.

| `npm run build:standalone`
| Generates a production-ready `/dist` folder for independent hosting.

| `npm run build:bundle`
| Generates a bundle optimized for link:https://brickengine.com.br[brickengine.com.br].

| `npm run lint` / `npm run format`
| Checks and fixes code style (if enabled during init).
|===

=== Manual Installation

If you prefer to integrate the engine into an existing project, install it via npm:

[source,bash]
----
npm install brick-engine-js p5
npm install --save-dev @types/p5
----

== Creating a Game

To create a game, you must extend the abstract `Game` class. If you used the CLI, this logic is already scaffolded in `src/index.ts`. Here is a reference implementation:

[source,typescript]
----
import { Game, FontSize, ControlKey, ControlEventType, Sound, FontAlign, FontVerticalAlign } from 'brick-engine-js';

export default class MyGame extends Game {
    /**
     * Called once after the engine and its modules are fully initialized.
     * Ideal for setting initial state, text sizes, and subscribing to controls.
     */
    setupGame(): void {
        // Example: Subscriber to ACTION button
        this.modules.control.subscribe(ControlKey.ACTION, ControlEventType.PRESSED, () => {
            console.log('Action pressed!');
            this.modules.sound.play(Sound.ACTION_1);
        });
    }

    /**
     * Called on every logic "tick". The frequency is defined by the game's tickInterval.
     * This is where movement, collision, and state updates should happen.
     * Logic here ONLY runs when the game is in the PLAYING state.
     */
    update(deltaTime: number): void {
        // Move players, check collisions, etc.
    }

    /**
     * Called every rendering frame (60fps).
     * Used for visual-only effects that don't impact game state (e.g. animations).
     * Runs during PLAYING and PAUSED states.
     */
    render(): void {
        const { text } = this.modules;

        text.setTextSize(FontSize.MEDIUM);
        text.setTextAlign(FontAlign.CENTER, FontVerticalAlign.CENTER);
        text.textOnDisplay('MY GAME', { x: 0.5, y: 0.4 });
        text.textOnDisplay('Playing', { x: 0.5, y: 0.6 });
    }

    /**
     * returns a unique key for LocalStorage.
     * Prevents data collisions between different games on the same domain.
     */
    getPersistenceKey(): string {
        return 'my-awesome-game-v1';
    }

    /**
     * Rendered every frame when the device is ON but the game hasn't started.
     * Usually displays the title and "Press Start" instructions.
     */
    drawTitleScreen(): void {
        const { text } = this.modules;

        text.setTextSize(FontSize.MEDIUM);
        text.setTextAlign(FontAlign.CENTER, FontVerticalAlign.CENTER);
        text.textOnDisplay('MY GAME', { x: 0.5, y: 0.4 });
        text.textOnDisplay('PRESS START', { x: 0.5, y: 0.6 });
    }

    /**
     * Rendered every frame when the game state reaches GAME OVER.
     * Replaces standard `render()` calls to show scores or restart messages.
     * Usually displays the game over message and "Press START to restart" instructions, and the final score.
     */
    drawGameOverScreen(): void {
        const { text, score } = this.modules;

        text.setTextSize(FontSize.MEDIUM);
        text.setTextAlign(FontAlign.CENTER, FontVerticalAlign.CENTER);
        text.textOnDisplay('GAME OVER', { x: 0.5, y: 0.4 });
        text.textOnDisplay(`SCORE: ${score.getScore()}`, { x: 0.5, y: 0.6 });
    }
}
----

== Next Steps

Once you've set up your project and created your game class, explore the modules documentation to learn about all the engine's capabilities.
