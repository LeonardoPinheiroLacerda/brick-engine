= GameState Module
:toc: macro
:toc-title: Table of Contents
:icons: font
:source-highlighter: highlight.js

toc::[]

The `GameState` module acts as the central hub for tracking the game's lifecycle and user preferences. It handles persistence to `localStorage` for settings like sound and color mode.

== State Properties

The module exposes several boolean properties that represent the game's current status:

* `on`: Is the device turned "on"?
* `start`: Has the "Start" button been pressed?
* `running`: Is the game loop actively updating logic?
* `gameOver`: Has the player lost?
* `muted`: Is sound disabled? (Persisted)
* `colorEnabled`: Is color mode active? (Persisted)
* `highScore`: The highest score achieved by the player. (Persisted)

NOTE: Modifying these properties directly (e.g., `state.gameOver = true`) automatically triggers the notification system, informing all subscribers.

== API Reference

=== `toggleOn()` / `toggleStart()` / `toggleRunning()` / `toggleGameOver()` / `toggleMuted()` / `toggleColorEnabled()`

Convenience methods to toggle the corresponding boolean state.

**Behavior**

Inverts the current boolean value. Automatically triggers a notification event to subscribers. Persists the new value if the property is `muted` or `colorEnabled`.

**Example**

[source,typescript]
----
this.modules.state.toggleMuted();
----

=== `subscribe(property: StateProperty, callback: (value: boolean | number) => void): void`

Subscribes to changes in a specific state property.

**Parameters**

[cols="1,1,3"]
|===
|Name |Type |Description
|`property` |`StateProperty` |The state property to monitor (e.g., `StateProperty.GAME_OVER`).
|`callback` |`(value: boolean \| number) => void` |Function to execute when the property changes.
|===


**Behavior**

Adds the callback to the list of listeners for the given property. The callback is invoked whenever the property's setter is called.

**Example**

[source,typescript]
----
state.subscribe(StateProperty.GAME_OVER, isOver => {
    if (isOver) {
        console.log('Game Over!');
    }
});
----

=== `unsubscribe(property: StateProperty, callback: (value: boolean | number) => void): void`

Unsubscribes a previously registered callback.

**Parameters**

[cols="1,1,3"]
|===
|Name |Type |Description
|`property` |`StateProperty` |The state property.
|`callback` |`(value: boolean \| number) => void` |The function reference to remove.
|===


**Behavior**

Removes the callback from the list.

**Example**

[source,typescript]
----
state.unsubscribe(StateProperty.GAME_OVER, onGameOver);
----

=== `setPersistenceKey(key: string): void`

Sets the unique persistence key for the game.

**Parameters**

[cols="1,1,3"]
|===
|Name |Type |Description
|`key` |`string` |The unique identifier for the game instance.
|===

**Behavior**

This key is used as a prefix for all `localStorage` keys (e.g., `my-game.muted`). It ensures that multiple games using the same engine do not overwrite each other's settings.

**Example**

[source,typescript]
----
state.setPersistenceKey('super-brick-v1');
----

=== `getPersistenceKey(): string`

Returns the currently set persistence key.

**Returns**

`string` - The persistence key.

=== Persistence

The module automatically saves `muted`, `colorEnabled`, and `highScore` preferences to the browser's `localStorage`. All keys are prefixed with the game's persistence key in the format: `${persistenceKey}.${storageKey}`.

== Central Persistence Responsibility

**GameState is the single source of truth for persistent state.**

Other modules (like `GameSound`) should **not** implement their own persistence logic. Instead, they should implement the `StateSyncable` interface and rely on `GameState` to inform them of the initial state and any subsequent changes via the `syncState(state: State)` method.

