= Game Class Reference
:toc: macro
:toc-title: Table of Contents
:icons: font
:source-highlighter: highlight.js

toc::[]

The `Game` class is the heart of your application. It initializes all necessary modules and sets up the main game loop.

== Inheritance

Your game class must extend `Game`.

[source,typescript]
----
import Game from '../core/Game';

class MyGame extends Game { ... }
----

== Properties

[cols="1,1,2"]
|===
|Property |Type |Description

|`modules`
|`GameModules`
|Access to all engine modules (grid, control, etc.).
|===

== API Reference

=== `processTick(deltaTime: number): void`

Abstract method called once per "Game Tick".

**Parameters**

[cols="1,1,3"]
|===
|Name |Type |Description
|`deltaTime` |`number` |Time elapsed since the last tick (in ms).
|===


**Behavior**

Executed at a fixed time step defined by `configs.game.tickInterval`. Should contain all state-changing game logic.

**Example**

[source,typescript]
----
processTick(deltaTime: number): void {
    this.modules.grid.shiftRowsDown(deltaTime);
}
----

=== `processFrame(): void`

Abstract method called every frame.



**Behavior**

Executed every render frame (typically 60fps). Used for interpolation, particles, or visual effects not affecting game state.

**Example**

[source,typescript]
----
processFrame(): void {
    this.particleSystem.update();
}
----

=== `setupGame(): void`

Abstract method called after initialization.


**Returns**

`void`

**Behavior**

Called once after all engine modules are set up and linked. Ideal place for subscribing to controls and setting initial state.

**Example**

[source,typescript]
----
setupGame(): void {
    this.modules.state.toggleStart();
}
----

== Accessing Modules

You can access any module via `this.modules`.

[source,typescript]
----
const { grid, control, state, text, time, renderer } = this.modules;

// Example: Move a piece
control.subscribe(ControlKey.DOWN, ControlEventType.PRESSED, () => {
    // ... move piece down ...
});
----
